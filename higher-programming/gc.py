a = 40      # 创建对象  <40>
b = a       # 增加引用， <40> 的计数
c = [b]     # 增加引用.  <40> 的计数

del a       # 减少引用 <40> 的计数
b = 100     # 减少引用 <40> 的计数
c[0] = -1   # 减少引用 <40> 的计数
"""垃圾回收机制不仅针对引用计数为 0 的对象，同样也可以处理循环引用的情况。循环引用指的是，
两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。
Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 
垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。
 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。"""
class Point:
    def __init__(self,x=0,y=0):
        self.x = x
        self.y = y

    def __del__(self):
        class_name = self.__class__.__name__
        print(class_name,"销毁")

pt1 = Point()
pt2 = pt1
pt3 = pt1
# 打印对象id
print(id(pt1),id(pt2),id(pt2),id(pt2))
del pt1
del pt2
del pt3